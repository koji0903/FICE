########################################################################
#
# Operation for anlizing synplicity.ucf
#
#    Author   : Koji HIJIKURO<koji.hijikuro@nms.necel.com>
#
########################################################################
#
#  Class Name : SynplicityUCF
#  
#  [Input]
#    - ucf_file : UCF File genereted by Synplify Pro
#
#  [Output]
#    - 
#
########################################################################
$:.unshift(File.dirname(__FILE__) + "/../lib")
require 'FICE_def'
require 'lexer'
module UCF

  ############################################
  #
  # Analyze UCF that generated by Synplify Pro
  #
  ############################################
  class ISEAnalyzed
    attr_accessor :sdc_name   # SDC Name
    attr_accessor :global_sw  # Global sw
    attr_accessor :syn_flag   # Use on synplify synthesis : "used/unused/none"
    attr_accessor :ucf_const  # converted ucd constraint
    attr_accessor :ise_flag   # true: used, false : unused (bld,map,par)
    attr_accessor :rep_result # result data from report
    def initialize
      @sdc_name = nil
      @global_sw = false
      @syn_flag = "none"
      @ucf_const = Array.new
      @ise_flag = "none"
      @rep_result = nil
    end

    def get_ts_name
      return ucf_const[2].split[1].gsub("\"","")
    end
  end


  ############################################
  #
  # Analyze UCF that generated by Synplify Pro
  #
  ############################################
  class SynplicityUCF

    attr_reader :UCFConst
    attr_reader :UnusedConstraintList
    attr_reader :UsedConstraintList
    attr_reader :UnusedClockList
    attr_reader :UsedClockList

    def initialize(ucf_file)
      @ucf_file = ucf_file

      # For Other program
      @UnusedConstraintList = Hash.new
      @UsedConstraintList   = Hash.new
      @UnusedClockList      = Array.new
      @UsedClockList        = Hash.new
    end
    
    private
    def file_check(file)
      return Common.chk_file("-ucf",file)
    end

    private 
    def read_file(file)
      return Common.file_read(file)
    end

    public
    def const_analyze(file)
      unused_const_flag = false
      used_const_flag = false
      used_const_key = nil
      used_const_value = Array.new
      # ErrorCheck
      return false  if file_check(file) == 1
      # Operation
      line_num = 1
      read_file(file).each{|line|
        # Judgement Line
        case line
        when "# Unused constraints (intentionally commented out)"
          unused_const_flag = true          
          if used_const_key != nil && used_const_flag == true
            @UsedConstraintList["#{used_const_key}"] = used_const_value
          end
        when "# I/O Registers Packing Constraints"
          unused_const_flag = false
        when %r(^#\s\d+)
          if used_const_key != nil && used_const_flag == true
            @UsedConstraintList["#{used_const_key}"] = used_const_value
          end
          used_const_flag = true
          used_const_key = line.split(" : ")[1]
          used_const_value = Array.new
        when %r(^#)
          used_const_flag = false
        end

        @UnusedConstraintList[line.sub("# ","")] = [line_num,line.sub("# ","")] if unused_const_flag && /# define.*/ =~ line; 
        used_const_value << [line_num,line] if used_const_flag && line.size != 0 && !(/^#/ =~ line) 
        
        line_num += 1
#        lexer = Lexer.new("#{line}")
#        tokens = lexer.tokens; #next if tokens.size == 0
      }
      return @UsedConstraintList, @UnusedConstraintList
    end

    def internal_error(file,line)
      $INTERNAL_ERROR_CNT += 1
      printf("@Internal error. (file:%s,line:%s)",file,line)
      Common.print_summary
      exit 1
    end

    def main
      return const_analyze(@ucf_file)      
    end
  end

  ############################################
  #
  # Analyze UCF that generated by Synplify Pro
  #
  ############################################
  class MkUCF < SynplicityUCF

    def clock_analyze(file)
      tmp = Array.new
      net = Hash.new # "NET" line info
      timegrp = Hash.new
      return false  if file_check(file) == 1
      read_file(file).each{|line|
        case line
        when %r(^NET)
          net_name = line.split[1].gsub("\"","")
          tnm_net  = line.split[4].gsub("\"","").gsub(";","") if line.split[2] == "TNM_NET"
          if tnm_net != nil
            net["#{tnm_net}"] = line
          end
        when %r(^TIMEGRP)
          tnm_net = line.split[3].gsub("\"","")
          if net["#{tnm_net}"] != nil
            timegrp["#{line.split[1].gsub("\"","")}"] = [tnm_net,net["#{tnm_net}"],line]
          end
        when %r(^TIMESPEC)
          grp_name = line.split[4].gsub("\"","")
          if line.split[1].gsub("\"","") == ( "TS_" + grp_name.gsub("_grp","") )
            clk_name = timegrp["#{grp_name}"]
            if clk_name != nil
              tmp = Array.new
              tmp << clk_name[1]
              tmp << clk_name[2]
              tmp << line
              @UsedClockList["#{clk_name[0]}"] = tmp
            end
          end
        else
        end
      }
      return @UsedClockList
    end


    def main
      return const_analyze(@ucf_file),clock_analyze(@ucf_file)
    end
  end

  ############################################
  #
  # Analyze SDC that generated by mksdc
  #
  ############################################
  class MksdcSDC
    attr_reader :SDCConstraintList

    def initialize(sdc_file)
      @sdc_file = sdc_file

      # For Other program
      @SDCConstraintList   = Array.new
    end
    
    private
    def file_check(file)
      return Common.chk_file("-sdc",file)
    end

    private 
    def read_file(file)
      return Common.file_read(file)
    end

    public
    def analyze(file)
      # ErrorCheck
      return false  if file_check(file) == 1
      # Operation
      read_file(file).each{|line|
        next if line.size == 0 # space
        next if line[0] == 35  # coment line
        @SDCConstraintList << line
#        lexer = Lexer.new("#{line}")
#        tokens = lexer.tokens; #next if tokens.size == 0
      }
      return @SDCConstraintList
    end

    def main
      return analyze(@sdc_file)
    end
  end

  ############################################
  #
  # Compare synplicity.ucf and sdc file
  #
  ############################################
  class ConstCompare
    def initialize(sdc_inf,ucf_inf)
      @sdc_inf = sdc_inf
      @used_ucf_inf = ucf_inf[0][0]
      @unused_ucf_inf = ucf_inf[0][1]
      @clock_inf = ucf_inf[1]

      # Unknows SDC Constraint ( not Found in UCF File )
      @UnknownSDC = Array.new
    end

    def analyze(used_ucf_inf,unused_ucf_inf,sdc_inf)
      total_num = 0
      analyzed_data = Hash.new # {attr => [ISEAnalyzed list]}
      sdc_inf.each{|each_sdc|
        next if each_sdc == " "
        analyzed = ISEAnalyzed.new
        analyzed.sdc_name = each_sdc
        analyzed.global_sw = true
        # Checking Unreflected Constraint List
        if used_ucf_inf["#{each_sdc}"] != nil 
          # Analyzed Constraint by Synplfy Pro
          analyzed.syn_flag = "used"
          analyzed.ucf_const = used_ucf_inf["#{each_sdc}"]
        elsif unused_ucf_inf["#{each_sdc}"] != nil
          analyzed.syn_flag = "unused"
        else
          analyzed.syn_flag = "none"
          # remove reserved attribute
          case each_sdc.split[0]
          when "define_clock"
            clock_name = each_sdc.split[6]
            if @clock_inf["#{clock_name}"] != nil
              analyzed.syn_flag = "used"
              analyzed.ucf_const = @clock_inf["#{clock_name}"]
            end
          when "define_clock_delay"
          when "define_attribute"
            analyzed.global_sw = false
          when "define_global_attribute"
            analyzed.global_sw = false
          when nil
          else    
            @UnknownSDC << each_sdc
#            $INTERNAL_ERROR_CNT += 1
#            printf("@Internal error. (file:%s,line:%s)\n",__FILE__,__LINE__)
#            p each_sdc
#            Common.print_summary
#            exit 1
          end
        end
        attr = analyzed.sdc_name.split[0]
        if analyzed_data.key?("#{attr}") == true
          tmp = Array.new
          tmp = analyzed_data["#{attr}"]
          tmp << analyzed
          analyzed_data["#{attr}"] = tmp
        else
          tmp = Array.new
          tmp << analyzed
          analyzed_data["#{attr}"] = tmp
        end
        total_num += 1 
      }
      return analyzed_data, total_num, @UnknownSDC
    end

    def main
      return analyze(@used_ucf_inf,@unused_ucf_inf,@sdc_inf)
    end
  end

  ############################################
  #
  # Compare EVA_TOP.par and sdc analyzed data
  #
  ############################################
  class AddBldResult
    def initialize(all_ana,bld_result)
      @all_ana = all_ana
      @bld_result = bld_result
    end
    def main
      @all_ana.each{|attr,sdc|
        sdc.each{|each_sdc|
          each_sdc.ucf_const.each{|each_ucf|
            if @bld_result.IgnoredLineNum.index("#{each_ucf[0]}") != nil
              each_sdc.ise_flag = "IncludeIgnoredConstraint"
              each_ucf[1] = each_ucf[1] + " # With ignored message in ISE Ngdbuild"
            end
          }
        }
      }
      return @all_ana
    end
  end

  ############################################
  #
  # Compare EVA_TOP.par and sdc analyzed data
  #
  ############################################
  class AddMapResult
    def initialize(all_ana,map_result)
      @all_ana = all_ana
      @map_result = map_result
    end
    def main
      @all_ana.each{|attr,sdc|
        sdc.each{|each_sdc|
          each_sdc.ucf_const.each{|each_ucf|
            if /TS_/ =~ each_ucf[1].to_s
              /\"(TS_\S*)\"/ =~ each_ucf[1].to_s
              if @map_result.IgnoredTSName.index("#{$1}") 
                each_sdc.ise_flag = "IgnoredConstraint"
              else
#                each_sdc.ise_flag = "none"
                break
              end
            end
          }
        }
      }
      
      return @all_ana
    end
  end


  ############################################
  #
  # Compare EVA_TOP.par and sdc analyzed data
  #
  ############################################
  class AddParResult
    def initialize(all_ana,par_result)
      @all_ana = all_ana
      @par_result = par_result
    end
    def main
      @all_ana.each{|attr,ucf|
        ts_name = nil
        par_flag = false
        case attr
        when "define_clock"
          ucf.each{|each_ucf|
            each_ucf.ucf_const.each{|ucf_line|
              if /TIMESPEC/ =~ ucf_line
                ts_name = ucf_line.split[1].gsub("\"","")
                if @par_result.key?("#{ts_name}")
                  par_flag = true
                end
              end
            }
            if par_flag && @par_result["#{ts_name}"] != nil
              each_ucf.rep_result = @par_result["#{ts_name}"]
            end
            par_flag = false
          }
        
        end
      }
      return @all_ana
    end
  end
end    
