########################################################################
#
# Operation for anlizing synplicity.ucf
#
#    Author   : Koji HIJIKURO<koji.hijikuro@nms.necel.com>
#
########################################################################
#
#  Class Name : XMLParse
#  
#  [Input]
#    - xml_file : xml_file generated by VerilogToXML
#
#  [Output]
#    - Circuit DB
#
#  [Limit Function]
#   1. cannnot analyze bus in port/wire parsing
# 
########################################################################
require 'rubygems'
require 'xml/libxml' 
require "FMakeMessage"
require 'FICE_DB'
#
# XML APIs
#  get all circuit information from XML
#  modife all circuit information at XML
#
module XMLParse
  SOURCE_TEXT      = "/source_text/description"
  # MODULE PATH Path in XML(/source_text/description/module/name_of_module/IDENTIFIER)
  MODULE_PATH      = "module"
  # MODULE_NAME PATH Path in XML(/source_text/description/module/name_of_module/IDENTIFIER)
  MODULE_NAME_PATH = "module/name_of_module/IDENTIFIER"


  # NAME OF MODULE Path in XML ( get module name)
  NAME_OF_MODULE   = "name_of_module/IDENTIFIER"
  # NAME_OF_VARIABLE( get Signal Name )
  NAME_OF_VARIABLE = "name_of_variable/IDENTIFIER"
  # NAME_OF_REGISTER( get Register Name )
  NAME_OF_REGISTER = "name_of_register/IDENTIFIER"
  # NAME_OF_MEMORY( get Memory Name )
  NAME_OF_MEMORY = "name_of_memory/IDENTIFIER"
  # NAME OF INSTANCE ( get instance name)
  NAME_OF_INSTANCE = "name_of_instance/IDENTIFIER"
  # PRIMARY 
  PRIMARY = "primary/IDENTIFIER"
  # NETTYPE
  NETTYPE = "NETTYPE"

  # for Caching Data
  INST_LIST = Hash.new
  WIRE_LIST = Hash.new
  PORT_LIST = Hash.new
  ALL_CONNECT = Hash.new
  CONNECT_LIST = Hash.new
  TERMINAL_LIST = Hash.new
  ADD_DOC = Hash.new

  NEXT_MODULE_BUS_PORTION = nil
  #
  # Add Doc for Replace/Add Module
  #
  public
  def add_doc(verilog,doc)
    printf"@I:Add Verilog information about %s\n",verilog
    ADD_DOC[verilog] = doc
  end

  #
  # Read XML File
  #  param : file - XML FileName
  #  ret   : doc (LibXML::XML::Document)
  #
  public
  def read(file)
    if FileTest.exist?(file)
      begin
        parser = XML::Parser.file("#{file}")
        return parser.parse
      rescue
        # Exception Error
        FMakeMessage.PrintError( :category => "XMLParse", :no => 50, :param => file)
        return false
      end
    else
      FMakeMessage.PrintInternalError( :category => "XMLParse", :no => 2, :file_name => File.basename(__FILE__), :lineno => __LINE__, :param => file)
      return false
    end
    return true
  end

  #
  # Save to XML File
  #  param : doc - LibXML::XML::Document, file - saved file name
  #  ret   : status (0:sucess, 1:fail)
  #
  public
  def save(doc,file)
    printf("@I:save XML file(%s).\n",file)
    if FileTest.exist?(file)
      FMakeMessage.PrintNote( :category => "XMLParse", :no => 1, :param => file)
    end
    return doc.save( "#{file}", :indent => true, :encoding => LibXML::XML::Encoding::UTF_8 )
  end


  # Get All module name include XML
  #  param : doc  (LibXML::XML::Document)
  #  ret   : Module List(Array)  ex: ["EVA_TOP","QLK0RCPUEVA"]
  public
  def get_ModuleList(doc)
    module_list = Array.new
    doc.root.find( "#{SOURCE_TEXT}/#{MODULE_PATH}/name_of_module/IDENTIFIER" ).each do |name_of_module|
      if module_list.index(name_of_module.content.strip).nil?
        module_list <<  name_of_module.content.strip
      else
        FMakeMessage.PrintError( :category => "XMLParse", :no => 67, :mod => name_of_module.content.strip )
      end
    end

=begin
    doc.root.find( "#{SOURCE_TEXT}" ).each do |source_text|
      source_text.find( "#{MODULE_PATH}" ).each do |node|
        node.find('name_of_module/IDENTIFIER').each do |name_of_module|
          module_list <<  name_of_module.content.strip
        end
      end
    end
=end

    if module_list == []
      FMakeMessage.PrintWarning( :category => "XMLParse", :no => 1, :file_name => File.basename(__FILE__), :lineno => __LINE__)
    end
    return module_list
  end


  # Change module name include XML
  #  param : doc  (LibXML::XML::Document)
  #          org
  #          mod       
  #  ret   : doc
  public
  def change_ModuleName(doc,org,mod)

    doc.root.find( "#{SOURCE_TEXT}/#{MODULE_PATH}/name_of_module/IDENTIFIER" ).each do |name_of_module|
      if  name_of_module.content.strip == org
        name_of_module.content = mod
      end
    end

=begin
    doc.root.find( "#{SOURCE_TEXT}" ).each do |source_text|
      source_text.find( "#{MODULE_PATH}" ).each do |node|
        node.find('name_of_module/IDENTIFIER').each do |name_of_module|
          if  name_of_module.content.strip == org
            name_of_module.content = mod
          end
        end
      end
    end
=end

    return doc
  end


  # Delete target module inf include XML
  #  param : doc  (LibXML::XML::Document)
  #  ret   : doc  (Modified)
  public
  def delete_Module(doc,target_module)
    printf("@I:delete module(%s) in xml.\n",target_module)

    doc.root.find( '/source_text/description' ).each do |description|
      description.find( 'module/name_of_module/IDENTIFIER' ).each do |name_of_module|
        if target_module == name_of_module.content.strip
          description.remove!
          return doc
        end
      end
    end

=begin
    doc.root.find( '/source_text' ).each do |source_text|
      source_text.find( 'description' ).each do |description|
        description.find( 'module' ).each do |node|
          node.find('name_of_module/IDENTIFIER').each do |name_of_module|
            if target_module == name_of_module.content.strip
              description.remove!
              return doc
            end
          end
        end
      end
    end
=end
    return doc
  end

  # Delete target module inf include XML
  #  param : doc  (LibXML::XML::Document)
  #  ret   : doc  (Modified)
  public
  def delete_HardMacro(doc)
    mod_name = nil
    module_list = Array.new
    delete_gate_list = ["nmos","pmos","cmos","rpmos"]
    printf("@I:delete HardMacro module in xml.\n")
    doc.root.find( '/source_text' ).each do |source_text|
      source_text.find( 'description' ).each do |description|
        description.find( 'module' ).each do |node|
          delete_flag = false

          node.find('name_of_module/IDENTIFIER').each do |name_of_module|            
            mod_name =  name_of_module.content.strip
          end

          node.find( 'module_item/gate_declaration/GATETYPE' ).each do |gate_item|
            if delete_gate_list.index(gate_item.content.strip) != nil
              delete_flag = true
              break
            end
          end
          node.find( 'module_item/net_declaration/list_of_assignments/assignment/expression/primary/concatenation/expression/primary/UNDEFINED_MACRO' ).each do |a|
            macro =  a.content.strip
            if /\`/ =~ macro
              delete_flag = true
              break
            end
          end
          node.find( 'module_item/event_declaration/reserved' ).each do |reserved|
            if reserved.content.strip == "event"
              delete_flag = true
              break
            end
          end
          node.find( 'module_item/continuous_assign/list_of_assignments/assignment/expression/primary/UNDEFINED_MACRO' ).each do |undefined_macro|
            if /\`/ =~ undefined_macro.content.strip
              delete_flag = true
              break
            end
          end

          if delete_flag
            # Delete Module
            description.remove!
            delete_flag = false
            module_list << mod_name
          end

        end
      end
    end
    return module_list
  end
  

  # Get All Terminal name reflated a module include XML
  #  param : doc  (LibXML::XML::Document)
  #          target_module
  #  ret   : Terminal List(Array) ex: ["PA0","PA1"]
  public
  def get_TerminalList(doc,target_module)
    terminal_list = Array.new
    module_name = nil
    # <module>
    # ::= module <name_of_module> <list_of_ports>? ;
    #		<module_item>*
    #		endmodule
    #	||= macromodule <name_of_module> <list_of_ports>? ;
    #		<module_item>*
    #		endmodule
    doc.root.find( "#{SOURCE_TEXT}" ).each do |source_text|
      source_text.find( "#{MODULE_PATH}" ).each do |node|
        # <name_of_module>
        #    ::= <IDENTIFIER>
        module_name = get_NAME_OF_MODULE(node)
        next if target_module != module_name
        # Search Traminal List include Taget Module
        node.find( 'list_of_ports').each do |list_of_port|
          #<list_of_ports>
          #	::= ( <port> <,<port>>* )
          list_of_port.find( 'port' ).each do |port|
            #<port>
            #	::= <port_expression>?
            #	||= . <name_of_port> ( <port_expression>? )
            port.find( 'port_expression' ).each do |port_expression|
              #<port_expression>
              #	::= <port_reference>
              #	||= { <port_reference> <,<port_reference>>* }
              port_expression.find( 'port_reference' ).each do |port_reference|
                #<port_reference>
                #	::= <name_of_variable>
                #	||= <name_of_variable> [ <constant_expression> ]
                #	||= <name_of_variable> [ <constant_expression> :<constant_expression> ]
                terminal_list +=  get_NAME_OF_VARIABLE(port_reference)
                
                port_reference.find( 'constant_expression' ).each do |constant_expression|
                  FMakeMessage.PrintInternalError( :category => "XMLParse", :no => 1, :file_name => File.basename(__FILE__), :lineno => __LINE__)
                end
                
              end
            end          
            port.find( 'name_of_port').each do |name_of_port|
              FMakeMessage.PrintInternalError( :category => "XMLParse", :no => 1, :file_name => File.basename(__FILE__), :lineno => __LINE__)
            end
            
          end
        end
      end
    end
    if terminal_list == []
#      FMakeMessage.PrintWarning( :category => "XMLParse", :no => 2, :file_name => File.basename(__FILE__), :lineno => __LINE__, :module_name => target_module)
    end
    return terminal_list
  end

  # Add Port related a module include XML
  #  param : doc  (LibXML::XML::Document), 
  #          target_module - Module Name instantiated target_inst
  #          add_port      - Port name
  #          con_db        - Connect Information
  #          check         - Enable Check function
  #  ret   : doc added port
  public
  def add_Terminal(doc,target_module,add_port,con_db=nil,check=true)
    # Error Check
    if check
#      TERMINAL_LIST[target_module]  = XMLParse::get_TerminalList(doc,target_module) if TERMINAL_LIST[target_module].nil?
#      sig = TERMINAL_LIST[target_module] 
      sig = XMLParse::get_TerminalList(doc,target_module)
      unless sig.index("#{add_port.Name}").nil?
        return 7
        FMakeMessage.PrintError( :category => "XMLParse", :no => 60, :pin_name => add_port.Name, :module_name => target_module, :connect_file => con_db.CONNECT_FILE, :line_no => con_db.PIN_INF[add_port.Name][0].LineNo)
      end
    end
    # Add Operation
    doc.root.find( "#{SOURCE_TEXT}" ).each do |source_text|
      source_text.find( "#{MODULE_PATH}" ).each do |node|
        module_name = get_NAME_OF_MODULE(node)
        next if target_module != module_name
        node.find( 'list_of_ports').each do |list_of_port|
          list_of_port << make_TerminalXML(add_port)
          list_of_port << "\n"
          return doc
        end
      end
    end
    FMakeMessage.PrintWarning( :category => "XMLParse", :no => 3, :file_name => File.basename(__FILE__), :lineno => __LINE__, :module_name => target_module, :add_port => add_port.Name ) unless add_flag
    return doc
  end

  # Delete Terminal related a module include XML
  #  param : doc  (LibXML::XML::Document), 
  #          target_module - Module Name instantiated target_inst
  #          add_port      - Port name
  #  ret   : doc deleted port
  public
  def delete_Terminal(doc,target_module,del_port)
    module_name = nil
    doc.root.find( "#{SOURCE_TEXT}" ).each do |source_text|
      source_text.find( "#{MODULE_PATH}" ).each do |node|
        module_name = get_NAME_OF_MODULE(node)
        next if target_module != module_name
        node.find( 'list_of_ports').each do |list_of_port|
          # Del Point
          list_of_port.find( 'port' ).each do |port|
            port.find( 'port_expression' ).each do |port_expression|
              port_expression.find( 'port_reference' ).each do |port_reference|
                if  [del_port] == get_NAME_OF_VARIABLE(port_reference)
                  port.remove!
                  return doc
                end
              end
            end
          end
        end
      end
    end
    FMakeMessage.PrintWarning( :category => "XMLParse", :no => 4, :file_name => File.basename(__FILE__), :lineno => __LINE__, :module_name => target_module, :add_port => add_port, :target => "terminal" )
    return doc
  end

  #
  # get Prameter Variable ( Now Not-Supported )
  # 
  private
  def get_Parameter(doc,target_module)    
    parameter_list = Hash.new
    module_name = nil
    flag = false
    doc.root.find( "#{SOURCE_TEXT}" ).each do |source_text|
      source_text.find( "#{MODULE_PATH}" ).each do |node|
      module_name = get_NAME_OF_MODULE(node)
        next if target_module != module_name 
        # Module Item
        node.find( 'module_item' ).each do |module_item|
          module_item.find( 'parameter_declaration' ).each do |parameter_declaration|
#            p parameter_declaration
          end
        end
      end
    end
  end

  # Get All Port name reflated a module include XML
  #  param : doc  (LibXML::XML::Document)
  #          target_module
  #  ret   : Port List(Hash) {name=>Signalinf} Port Class refer FICE_DB
  public
  def get_PortList(doc,target_module)
    port_list = nil
    port_list = get_PortListBase(doc,target_module)
    # Search Add File
    ADD_DOC.each do |file,doc|
#      printf("Search \"%s\" module in added file %s\n",target_module,file) if $VERBOSE
      port_list_tmp = XMLParse::get_PortListBase(doc,target_module)
      port_list = port_list_tmp unless port_list_tmp == {}
    end if ADD_DOC != {} && port_list == {}
    return port_list
  end

  private
  def get_PortListBase(doc,target_module)    
    port_list = Hash.new
    module_name = nil
    flag = false

    doc.root.find( "#{SOURCE_TEXT}/#{MODULE_PATH}" ).each do |node|
      module_name = get_NAME_OF_MODULE(node)
      next if target_module != module_name 
      direction = nil
      # Module Item
      node.find( 'module_item' ).each do |module_item|
        # Input Declaration
        module_item.find( 'input_declaration' ).each do |declaration|
          direction = "input"
          name,msb,lsb = declaration(declaration)
          port_list = save_SignalList(port_list,direction,name,msb,lsb)
        end
        # Output Declaration
        module_item.find( 'output_declaration' ).each do |declaration|
          direction = "output"
          name,msb,lsb = declaration(declaration)
          port_list = save_SignalList(port_list,direction,name,msb,lsb)
        end
        # Inout Declaration
        module_item.find( 'inout_declaration' ).each do |declaration|
          direction = "inout"
          name,msb,lsb = declaration(declaration)
          port_list = save_SignalList(port_list,direction,name,msb,lsb)
        end
        flag = true
      end
      return port_list if flag
    end
    return port_list

=begin
    doc.root.find( "#{SOURCE_TEXT}" ).each do |source_text|
      source_text.find( "#{MODULE_PATH}" ).each do |node|
      module_name = get_NAME_OF_MODULE(node)
        next if target_module != module_name 
        direction = nil
        # Module Item
        node.find( 'module_item' ).each do |module_item|
          # Input Declaration
          module_item.find( 'input_declaration' ).each do |declaration|
            direction = "input"
            name,msb,lsb = declaration(declaration)
            port_list = save_SignalList(port_list,direction,name,msb,lsb)
          end
          # Output Declaration
          module_item.find( 'output_declaration' ).each do |declaration|
            direction = "output"
            name,msb,lsb = declaration(declaration)
            port_list = save_SignalList(port_list,direction,name,msb,lsb)
          end
          # Inout Declaration
          module_item.find( 'inout_declaration' ).each do |declaration|
            direction = "inout"
            name,msb,lsb = declaration(declaration)
            port_list = save_SignalList(port_list,direction,name,msb,lsb)
          end
          flag = true
        end
        return port_list if flag
      end
    end
    return port_list
=end
  end

  # Get All Port direction reflated a module/signal include XML
  #  param : doc  (LibXML::XML::Document)
  #          target_module
  #          target_port
  #  ret   : direction(input/output/inout)
  public
  def get_PortDirection(doc,target_module,target_port,error_flag = true)    
    return "Unknown" if target_module.nil?

    port_list = {}
    if PORT_LIST[target_module] == nil
      PORT_LIST[target_module] = get_PortList(doc,target_module)
    end
    port_list = PORT_LIST[target_module]
#    port_list = XMLParse::get_PortList(doc,target_module) # Ret [SignalInf,...] 
    if port_list == {}
#      FMakeMessage.PrintNote( :category => "XMLParse", :no => 66, :module_name => target_module)  unless target_module.nil?
      return "Unknown"
    else
      port_list.each do |name,signal_inf|
        if name == target_port  
          return signal_inf.Type 
        end
      end
      # Error Not Found target_port
      FMakeMessage.PrintError( :category => "XMLParse", :no => 65, :pin_name => target_port, :module_name => target_module) if error_flag
    end
  end

  # Get All Port Inf reflated a module/signal include XML
  #  param : doc  (LibXML::XML::Document)
  #          target_module
  #          target_port
  #  ret   : direction(input/output/inout)
  public
  def get_PortInf(doc,target_module,target_port,error_flag = true)    
    return "Unknown" if target_module.nil?
      
    port_list = {}
    if PORT_LIST[target_module] == nil
      PORT_LIST[target_module] = get_PortList(doc,target_module)
    end
    port_list = PORT_LIST[target_module]
#    port_list = XMLParse::get_PortList(doc,target_module) # Ret [SignalInf,...] 
    if port_list == {}
#      FMakeMessage.PrintNote( :category => "XMLParse", :no => 66, :module_name => target_module)  unless target_module.nil?
      return "Unknown"
    else
      port_list.each do |name,signal_inf|
        if name == target_port  
          return signal_inf 
        end
      end
      # Error Not Found target_port
      FMakeMessage.PrintError( :category => "XMLParse", :no => 65, :pin_name => target_port, :module_name => target_module) if error_flag
    end
  end


  # Add Port inf reflated a module include XML
  #  param : doc  (LibXML::XML::Document)
  #          target_module
  #          conf_db       - Connect Information
  #          check         - enable check function
  #  ret   : doc added Port inf
  public
  def add_Port(doc,target_module,port,con_db=nil,check=true)
    # Error Check
#    if check
=begin !!Cache NG!!
      sig = nil
      if PORT_LIST[target_module] == nil
        PORT_LIST[target_module] = get_PortList(doc,target_module)
      end
      sig = PORT_LIST[target_module]
=end
    sig = XMLParse::get_PortList(doc,target_module)
    if sig["#{port.Name}"] != nil
      # Skip Add Port function
      return doc
=begin
      if con_db != nil
        FMakeMessage.PrintError( :category => "XMLParse", :no => 61, :pin_name => port.Name, :module_name => target_module, 
                                 :connect_file => con_db.CONNECT_FILE, :line_no => con_db.PIN_INF[port.Name][0].LineNo)
      else
        FMakeMessage.PrintError( :category => "XMLParse", :no => 61, :pin_name => port.Name, :module_name => target_module, :connect_file => "None", :line_no => 0)
      end
=end
    else
      #    end
      # Add Operation
      doc.root.find( "#{SOURCE_TEXT}/#{MODULE_PATH}" ).each do |node|
        module_name = get_NAME_OF_MODULE(node)
        next if target_module != module_name 
        
        node.find( 'module_item' ).each do |module_item|
          module_item.prev = make_PortXML(port)
          return doc
        end
      end
      FMakeMessage.PrintWarning( :category => "XMLParse", :no => 3, :file_name => File.basename(__FILE__), :lineno => __LINE__, :module_name => target_module, :add_port => add_port )
      return doc
    end
  end

  # Delete Port related a module include XML
  #  param : doc  (LibXML::XML::Document), 
  #          target_module - Module Name instantiated target_inst
  #          add_port      - Port name
  #  ret   : doc added port
  public
  def delete_Port(doc,target_module,add_port)
    doc.root.find( "#{SOURCE_TEXT}" ).each do |source_text|
      source_text.find( "#{MODULE_PATH}" ).each do |node|
        module_name = get_NAME_OF_MODULE(node)
        next if target_module != module_name 
        direction = nil
        # Module Item
        node.find( 'module_item' ).each do |module_item|
          module_item.find( '*' ).each do |declaration|
#        node.find( 'module_item/*' ).each do |declaration|
          port_list = declaration(declaration)[0]
          case port_list.size
          when 1
            if [add_port] == port_list
              #declaration.remove!
              module_item.remove!
              return doc
            end              
          else
            declaration.find( 'list_of_variables/name_of_variable' ).each do |name_of_variable|
              name_of_variable.find( '*' ).each do |identifier|
                if add_port == identifier.content.strip.split[0]
                  name_of_variable.remove!
                  return doc
                end
              end
            end
          end
          end
        end
      end
    end
    FMakeMessage.PrintWarning( :category => "XMLParse", :no => 4, :file_name => File.basename(__FILE__), :lineno => __LINE__, :module_name => target_module, :add_port => add_port, :target => "port" )
    return doc
  end



  # Get All Wire name reflated a module include XML
  #  param : doc  (LibXML::XML::Document)
  #          target_module
  #  ret   : Wire List(Array) ex: ["Port1","Port2"]. Port Class refer FICE_DB
  public
  def get_WireList(doc,target_module)
    wire_list = Hash.new
    module_name = nil
    doc.root.find( "#{SOURCE_TEXT}" ).each do |source_text|
      source_text.find( "#{MODULE_PATH}" ).each do |node|
        module_name = get_NAME_OF_MODULE(node)
        if target_module == module_name 
          # Module Item
          node.find( 'module_item' ).each do |module_item|
            module_item.find( 'net_declaration' ).each do |net_declaration|
              #<net_declaration>
              #	::= <NETTYPE> <expandrange>? <delay>? <list_of_variables> ;
              #	||= trireg <charge_strength>? <expandrange>? <delay>?
              case get_NETTYPE(net_declaration)
              when "wire"
                name,msb,lsb = declaration(net_declaration)
                wire_list = save_SignalList(wire_list,"wire",name,msb,lsb)
              end
            end
          end
          return wire_list
        end
      end
    end
    return wire_list
  end
  

  # Add Wire related a module include XML
  #  param : doc  (LibXML::XML::Document), 
  #          target_module - Module Name instantiated target_inst
  #          add_wire      - Wire name
  #          con_db        - Connect Information
  #          check         - enable check function
  #  ret   : doc added wire
  public
  def add_Wire(doc,target_module,add_wire,con_db=nil,check=true)
    # Error Check
    if check
      wire = XMLParse::get_WireList(doc,target_module)
      wire_a = Array.new
      wire.each_value do |wire_list|
        wire_a << wire_list.Name
      end
      
      # Already Exist same Wire name
      if wire_a.index("#{add_wire.Name}") != nil
        return doc
        FMakeMessage.PrintError( :category => "XMLParse", :no => 64, :pin_name => add_wire.Name, :module_name => target_module, :connect_file => con_db.CONNECT_FILE)
      end
    end
    # Add Operation
    doc.root.find( "#{SOURCE_TEXT}" ).each do |source_text|
      source_text.find( "#{MODULE_PATH}" ).each do |node|
        module_name = get_NAME_OF_MODULE(node)
        next if target_module != module_name 
        # Module Item
        node.find( 'module_item' ).each do |module_item|
          module_item.prev = xml_MultiNode(add_wire,"module_item/net_declaration")
          module_item << "\n"
          return doc
        end
      end
    end
    FMakeMessage.PrintWarning( :category => "XMLParse", :no => 3, :file_name => File.basename(__FILE__), :lineno => __LINE__, :module_name => target_module, :add_port => add_port )
    return doc
  end

  # Delete Wire related a module include XML
  #  param : doc  (LibXML::XML::Document), 
  #          target_module - Module Name instantiated target_inst
  #          del_wire      - Wire name
  #  ret   : doc added wire
  public
  def delete_Wire(doc,target_module,del_wire)
    doc.root.find( "#{SOURCE_TEXT}" ).each do |source_text|
      source_text.find( "#{MODULE_PATH}" ).each do |node|    
        module_name = get_NAME_OF_MODULE(node)
        next if target_module != module_name 
        # Module Item
        node.find( 'module_item' ).each do |module_item|
          module_item.find( 'net_declaration' ).each do |net_declaration|
            case get_NETTYPE(net_declaration)
            when "wire"
              wire_list = declaration(net_declaration)[0]
              case wire_list.size
              when 1
                if [del_wire] == wire_list
                  net_declaration.remove!
                  return doc
                end              
              else
                net_declaration.find( 'list_of_variables/name_of_variable' ).each do |name_of_variable|
                  name_of_variable.find( '*' ).each do |identifier|
                    if del_wire == identifier.content.strip.split[0]
                      name_of_variable.remove!
                      return doc
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
    FMakeMessage.PrintWarning( :category => "XMLParse", :no => 4, :file_name => File.basename(__FILE__), :lineno => __LINE__, :module_name => target_module, :add_port => del_wire, :target => "wire" )
    return doc
  end


  # Get All Reg name reflated a module include XML
  #  param : doc  (LibXML::XML::Document)
  #          target_module
  #  ret   : Wire List(Array) ex: ["Port1","Port2"]. Port Class refer FICE_DB
  public
  def get_RegList(doc,target_module)    
    reg_list = Hash.new
    module_name = nil
    doc.root.find( "#{SOURCE_TEXT}" ).each do |source_text|
      source_text.find( "#{MODULE_PATH}" ).each do |node|    
        module_name = get_NAME_OF_MODULE(node)
        if target_module == module_name 
          # Module Item
          node.find( 'module_item' ).each do |module_item|
            module_item.find( 'reg_declaration' ).each do |reg_declaration|
              #<reg_declaration>
              #	::= reg <range>? <list_of_register_variables> ;
              name,msb,lsb,word_top,word_buttom = reg_declaration(reg_declaration)
              if word_top == nil
                reg_list = save_SignalList(reg_list,"reg",name,msb,lsb,word_top,word_buttom)
              else
                reg_list = save_SignalList(reg_list,"mem",name,msb,lsb,word_top,word_buttom)
              end
            end
          end
        end
      end
    end
    return reg_list
  end

  # Get All Instance inf reflated a module include XML
  #  param : doc  (taLibXML::XML::Document)
  #          target_module : Module Name 
  #  ret   : Instance List(Array [ModuleName,InstanceName]) ex: [["QLK0RCPUEVA","cpu"],["QLK0RDMA","dma"]]
  public
  def get_InstanceList(doc,target_module)
    instance_list = Array.new
    module_name = nil
    flag = false
    doc.root.find( "#{SOURCE_TEXT}" ).each do |source_text|
      source_text.find( "#{MODULE_PATH}" ).each do |node|
        module_name = get_NAME_OF_MODULE(node)
        next if target_module != module_name
        node.find( 'module_item/module_instantiation' ).each do |module_instantiation|
          #<module_instantiation>
          #	::= <name_of_module> <parameter_value_assignment>?
          #		<module_instance> <,<module_instance>>* ;
          instance_list_each = Array.new
          module_instantiation.find( "#{NAME_OF_MODULE}" ).each do |module_name|
            instance_list_each << module_name.content.strip.split[0]
          end          
          # get Instance Name
          module_instantiation.find( 'module_instance' ).each do |module_instance|
            #<module_instance>
              #	::= <name_of_instance> ( <list_of_module_connections>? )
            instance_list_each << get_NAME_OF_INSTANCE(module_instance)
          end          
         module_instantiation.find( 'parameter_value_assignment' ).each do |parameter_value_assignment|
            FMakeMessage.PrintInternalError( :category => "XMLParse", :no => 1, :file_name => File.basename(__FILE__), :lineno => __LINE__)
          end          
          # Save array
          instance_list << instance_list_each
        end
        return instance_list
      end
    end
    return instance_list
  end

  # change Instance Module reflated a instance include XML
  #  param : doc  (LibXML::XML::Document)
  #          target_module - Target Module Name
  #          target_inst   - Target Instance Name
  #          change_module - Changing Module name 
  #          change_inst   - Changing Instance Name (Option)
  #  ret   : doc
  public
  def change_InstanceModule(doc,target_module,target_inst,change_module,change_inst=nil)
    get_inst_name = nil
    doc.root.find( "#{SOURCE_TEXT}" ).each do |source_text|
      source_text.find( "#{MODULE_PATH}" ).each do |node|
        module_name = get_NAME_OF_MODULE(node)
        next if target_module != module_name
        node.find( 'module_item/module_instantiation' ).each do |module_instantiation|
          module_instantiation.find( 'module_instance' ).each do |module_instance|
            module_instance.find( 'name_of_instance/IDENTIFIER' ).each do |inst_name|
              get_inst_name = inst_name.content.strip.split[0]
              # Change Instance Name
              inst_name.content = change_inst unless change_inst.nil?
            end   
          end     
          next if get_inst_name != target_inst
          module_instantiation.find( "#{NAME_OF_MODULE}" ).each do |module_name|
            # Change Module Name
            module_name.content = change_module
            return true
          end          
        end
      end
    end
    return false
  end


  # Get All Connect inf reflated a module/instance include XML
  #  param : doc  (LibXML::XML::Document)
  #          module_name - Target Module Name 
  #          inst_name - Target Instance Name
  #  ret   : Connect List(Array [PortName,FICE_DB::SignalInf,...])
  public
  def get_ConnectList(doc,target_module,target_inst)
    connect_list = Hash.new
    module_name = nil
    named_port_num = 0
    doc.root.find( "#{SOURCE_TEXT}" ).each do |source_text|
      source_text.find( "#{MODULE_PATH}" ).each do |node|
      
        # Get Module Name
        node.find( "#{NAME_OF_MODULE}" ).each do |mod_name|
          module_name =  mod_name.content.strip.split[0]
        end
        
        next if module_name != target_module
        # Module Information
        node.find( 'module_item' ).each do |module_item|
          #<module_item>
          #	::= <parameter_declaration>
          #	||= <input_declaration>
          #	||= <output_declaration>
          #	||= <inout_declaration>
          #	||= <net_declaration>
          #	||= <reg_declaration>
          #	||= <time_declaration>
          #	||= <integer_declaration>
          #	||= <real_declaration>
          #	||= <event_declaration>
          #	||= <gate_declaration>
          #	||= <UDP_instantiation>
          #	||= <module_instantiation>
          #	||= <parameter_override>
          #	||= <continuous_assign>
          #	||= <specify_block>
          #	||= <initial_statement>
          #	||= <always_statement>
          #	||= <task>
          #	||= <function>
          module_item.find( 'module_instantiation' ).each do |module_instantiation|
            #<module_instantiation>
            #	::= <name_of_module> <parameter_value_assignment>?
            #		<module_instance> <,<module_instance>>* ;
            
            # get Instance Name
            inst_name = nil
            instantiated_module_name = get_NAME_OF_MODULE(module_instantiation)
            module_instantiation.find( 'module_instance' ).each do |module_instance|
              #<module_instance>
              #	::= <name_of_instance> ( <list_of_module_connections>? )              
              
              # name_of_instance
              inst_name =  get_NAME_OF_INSTANCE(module_instance)
              
              # Analyze only target_inst
              next if target_inst != inst_name
              module_instance.find( 'list_of_module_connections' ).each do |list_of_module_connections|
                #<list_of_module_connections>
                #	::= <module_port_connection> <,<module_port_connection>>*
                #	||= <named_port_connection> <,<named_port_connection>>*
                # named_port_connection
                list_of_module_connections.find( 'named_port_connection' ).each do |named_port_connection|
                  connect_list = get_named_port_connection(doc,connect_list,named_port_connection,target_module)
                end
                
                # module_port_connection
                list_of_module_connections.find( 'module_port_connection' ).each do |module_port_connection|
                  #<module_port_connection>
                  #	::= <expression>
                  #	||= <NULL>
                  module_port_connection.find( 'expression' ).each do |expression|
                    #<expression>
                    #	::= <primary>
                    #	||= <UNARY_OPERATOR> <primary>
                    #	||= <expression> <BINARY_OPERATOR> <expression>
                    #	||= <expression> <QUESTION_MARK> <expression> : <expression>
                    #	||= <STRING>
                    connect_list_each = Array.new 
                    wire_name =  get_expression(expression)                    

                    WIRE_LIST[target_module] =  XMLParse::get_WireList(doc,target_module) if WIRE_LIST[target_module].nil?
                    net_inf =  WIRE_LIST[target_module][wire_name]

#                    net_inf =  XMLParse::get_WireList(doc,target_module)[wire_name]
                    if net_inf != nil                 
                      signal = FICE_DB::SignalInf.new( :name => wire_name, :type => "wire", :msb => net_inf.MSB, :lsb => net_inf.LSB, 
                                                       :portion => net_inf.BusPortion, :word_top => net_inf.WordTop, :word_buttom => net_inf.WordButtom)
                    else
                      signal = FICE_DB::SignalInf.new( :name => wire_name, :type => "wire" )
                    end
                    instantiated_port_inf = nil
                    if TERMINAL_LIST[instantiated_module_name] == nil
                      instantiated_port_inf = XMLParse::get_TerminalList(doc,instantiated_module_name)
                      TERMINAL_LIST[instantiated_module_name] = instantiated_port_inf 
                    else
                      instantiated_port_inf = TERMINAL_LIST[instantiated_module_name]
                    end
                    name = instantiated_port_inf[named_port_num]
                    connect_list[name] = [signal]
                    named_port_num += 1
                    return connect_list
                  end
                end
                return connect_list
              end
            end
          end
        end
      end
    end
    return connect_list
  end
  # Get All Connect inf reflated a module/instance include XML
  #  param : doc  (LibXML::XML::Document)
  #          module_name - Target Module Name 
  #          inst_name - Target Instance Name
  #  ret   : Connect List(Array [PortName,FICE_DB::SignalInf,...])
  public
  def get_ConnectListwithPort(doc,target_module,target_inst,port_name)
    connect_list = Hash.new
    module_name = nil
    named_port_num = 0
    doc.root.find( "#{SOURCE_TEXT}" ).each do |source_text|
      source_text.find( "#{MODULE_PATH}" ).each do |node|
      
        # Get Module Name
        node.find( "#{NAME_OF_MODULE}" ).each do |mod_name|
          module_name =  mod_name.content.strip.split[0]
        end
        
        next if module_name != target_module
        # Module Information
        node.find( 'module_item' ).each do |module_item|
          module_item.find( 'module_instantiation' ).each do |module_instantiation|
            inst_name = nil
            module_instantiation.find( 'module_instance' ).each do |module_instance|
              inst_name =  get_NAME_OF_INSTANCE(module_instance)
              
              # Analyze only target_inst
              next if target_inst != inst_name
              module_instance.find( 'list_of_module_connections' ).each do |list_of_module_connections|
                list_of_module_connections.find( 'named_port_connection' ).each do |named_port_connection|
                  connect_list = get_named_port_connection(doc,connect_list,named_port_connection,target_module)
                  if connect_list[port_name] != nil
                    return connect_list[port_name]
                  end
                end
                return connect_list
              end
            end
          end
        end
      end
    end
    return connect_list
  end
  # Get All Connect inf reflated a module/instance include XML
  #  param : doc  (LibXML::XML::Document)
  #          module_name - Target Module Name 
  #          inst_name - Target Instance Name
  #  ret   : Connect List(Array [PortName,FICE_DB::SignalInf,...])
  public
  def get_AllConnectList(doc,target_module)
    all_connect = Hash.new
    connect_list = Hash.new
    result = nil
    module_name = nil
    flag = false
    named_port_num = 0
    doc.root.find( "#{SOURCE_TEXT}" ).each do |source_text|
      source_text.find( "#{MODULE_PATH}" ).each do |node|
      
        # Get Module Name
        node.find( "#{NAME_OF_MODULE}" ).each do |mod_name|
          module_name =  mod_name.content.strip.split[0]
        end
        next if module_name != target_module
        # Module Information
        node.find( 'module_item' ).each do |module_item|
          named_port_num = 0
          module_item.find( 'module_instantiation' ).each do |module_instantiation|
            inst_name = nil
            instantiated_module_name = get_NAME_OF_MODULE(module_instantiation)
            module_instantiation.find( 'module_instance' ).each do |module_instance|
              inst_name =  get_NAME_OF_INSTANCE(module_instance)
              
              # Analyze only target_inst
              module_instance.find( 'list_of_module_connections' ).each do |list_of_module_connections|
                list_of_module_connections.find( 'named_port_connection' ).each do |named_port_connection|                 
                  connect_list = get_named_port_connection(doc,connect_list,named_port_connection,target_module)
                end
                list_of_module_connections.find( 'module_port_connection' ).each do |module_port_connection|
                  module_port_connection.find( 'expression' ).each do |expression|
                    wire_name =  get_expression(expression)
                    net_inf_all = nil
                    net_inf = nil
                    if WIRE_LIST[target_module] == nil
                      WIRE_LIST[target_module] =  XMLParse::get_WireList(doc,target_module)
                    end
                    net_inf_all = WIRE_LIST[target_module]
                    net_inf =  net_inf_all[wire_name]
                  
                    if net_inf != nil
                      signal = FICE_DB::SignalInf.new( :name => wire_name, :type => "wire", :msb => net_inf.MSB, :lsb => net_inf.LSB, 
                                                       :portion => net_inf.BusPortion, :word_top => net_inf.WordTop, :word_buttom => net_inf.WordButtom)
                    else
                      signal = FICE_DB::SignalInf.new( :name => wire_name, :type => "wire" )
                    end
                    instantiated_port_inf = nil
                    if TERMINAL_LIST[instantiated_module_name] == nil
                      TERMINAL_LIST[instantiated_module_name]  = XMLParse::get_TerminalList(doc,instantiated_module_name)
                    end
                    instantiated_port_inf = TERMINAL_LIST[instantiated_module_name]
                    name = instantiated_port_inf[named_port_num]
                    connect_list[name] = [signal]
                    named_port_num += 1
                  end
                end
              end
              all_connect[inst_name] = connect_list
              connect_list = Hash.new # Clear
            end
          end
        end
#        return all_connect
      end
    end
    return all_connect
  end

  # Add Instance related a module include XML
  #  param : doc  (LibXML::XML::Document), 
  #          target_module - Module Name instantiated target_inst
  #          inst_inf      - Adding Instance XML inf
  #  ret   : doc added Instance
  public
  def add_Instance(doc,target_module,inst_inf,conf_db=nil,check=true)
    # Error Check
    if check
      INST_LIST[target_module] = get_InstanceList(doc,target_module) if INST_LIST[target_module].nil?
      inst = INST_LIST[target_module] 
#      inst = XMLParse::get_InstanceList(doc,target_module)
      inst_a = Array.new
      inst.each do |inst_list|
        inst_a << inst_list[1]
      end
      unless inst_a.index("#{inst_inf[1]}").nil?
        printf("\n") 
        FMakeMessage.PrintError( :category => "XMLParse", :no => 62, :inst_name => inst_inf[1], :module_name => target_module, :conf_file => conf_db.CONF_FILE)
      end
    end
    # Add Operation
    doc.root.find( "#{SOURCE_TEXT}" ).each do |source_text|
      source_text.find( "#{MODULE_PATH}" ).each do |node|
        module_name = get_NAME_OF_MODULE(node)
        next if target_module != module_name
        node.find("reserved").each do |a|
          a.remove! if a.content == "endmodule"
        end
        node << xml_addInstanceNode(inst_inf,"module_item/module_instantiation",port_path="name_of_module/IDENTIFIER",value_path="module_instance/name_of_instance/IDENTIFIER")        
        node << xml_NodeWithItem("endmodule","reserved",nil,nil,false) # Without FMake Comment
        return doc
      end
    end
    return doc
  end


  # Add Instance Port related a module include XML
  #  param : doc  (LibXML::XML::Document), 
  #          target_module - Module Name instantiated target_inst
  #          target_inst   - Target Instance
  #          add_port      - Adding Instance Port name(FICE_DB::)
  #          con_db        - Conenct File Infromation
  #          check         - Enable Check function
  #  ret   : doc added Instance
  public
  def add_InstancePort(doc,target_module,target_inst,add_port,con_db=nil,check=true)
    # Error Check
    if check
      str = target_module + "." + target_inst
      if CONNECT_LIST[str] == nil
        CONNECT_LIST[str] = XMLParse::get_ConnectList(doc,target_module,target_inst)
      end
      sig = CONNECT_LIST[str]
#      sig = XMLParse::get_ConnectList(doc,target_module,target_inst)
      unless sig["#{add_port[0]}"] == nil
        FMakeMessage.PrintError( :category => "XMLParse", :no => 63, :pin_name => add_port[0], :module_name => target_module, :connect_file => con_db.CONNECT_FILE, :line_no => con_db.PIN_INF[add_port[0]][0].LineNo)
      end
    end
    # add Operation
    doc.root.find( "#{SOURCE_TEXT}" ).each do |source_text|
      source_text.find( "#{MODULE_PATH}" ).each do |node|
        # Get Module Name
        module_name = nil
        node.find( "#{NAME_OF_MODULE}" ).each do |mod_name|
          module_name =  mod_name.content.strip.split[0]
        end
        next if module_name != target_module
        # Module Information
        node.find( 'module_item' ).each do |module_item|
          module_item.find( 'module_instantiation' ).each do |module_instantiation|
            # get Instance Name
            inst_name = nil
            module_instantiation.find( 'module_instance' ).each do |module_instance|

              inst_name =  get_NAME_OF_INSTANCE(module_instance)
              
              # Analyze only target_inst
              next if target_inst != inst_name
              if module_instance.find( 'list_of_module_connections' ).empty? == false
                module_instance.find( 'list_of_module_connections' ).each do |list_of_module_connections|
=begin                  
                  list_of_module_connections.find( 'named_port_connection' ).each do |named_port_connection|
                    named_port_connection.prev =  xml_InstanceNode(port_inf)
                    return doc
                  end
=end
                  add_port.each do |key,value|
                    port_name = key
                    port_inf = value
                    list_of_module_connections <<  xml_InstanceNode(port_name,port_inf)                  
                  end

                  return true
                end
              else
                if add_port != nil
                  add_port.each do |key,value|
                    port_name = key
                    port_inf = value
                    module_instance << xml_InstanceNodeFirst(port_name,port_inf)
                  end
                else # Add Instance "Empty" Port
                  p xml_InstanceNodeFirst(port_name,nil)
                  exit
                end
                return true
              end
            end
          end
        end
      end
    end
    return false
  end

  # Delete Instance related a module include XML
  #  param : doc  (LibXML::XML::Document), 
  #          target_module - Module Name instantiated target_inst
  #          target_inst   - Target Inst
  #          target_port   - Port name
  #  ret   : doc added Instance
  public
  def delete_InstancePort(doc,target_module,target_inst,target_port)
    module_name = nil
    doc.root.find( "#{SOURCE_TEXT}" ).each do |source_text|
      source_text.find( "#{MODULE_PATH}" ).each do |node|      
        # Get Module Name
        node.find( "#{NAME_OF_MODULE}" ).each do |mod_name|
          module_name =  mod_name.content.strip.split[0]
        end
        next if module_name != target_module
        # Module Information
        node.find( 'module_item' ).each do |module_item|
          module_item.find( 'module_instantiation' ).each do |module_instantiation|
            inst_name = nil
            module_instantiation.find( 'module_instance' ).each do |module_instance|
              inst_name =  get_NAME_OF_INSTANCE(module_instance)
              
              # Analyze only target_inst
              next if target_inst != inst_name
              module_instance.find( 'list_of_module_connections' ).each do |list_of_module_connections|
                list_of_module_connections.find( 'named_port_connection' ).each do |named_port_connection|
                  named_port_connection.find( 'IDENTIFIER' ).each do |named_port|
                    port_name = named_port.content.strip.split[0]
                    if port_name == target_port
                      named_port_connection.remove!
                      return true
                    end
                  end
                end                
              end
            end
          end
        end
      end
    end
    return false
  end


  # Get All Connect Path 
  #  param : doc  (LibXML::XML::Document)
  #          target_module - Target Module Name 
  #          target_inst   - Target Instance Name
  #          target_port   - Target Port
  #          search_all    - Search All Hierarchy (true/false)
  #          hier          - Next Search Category(Top/NextModule/Connect/Middle)
  #          num           - Space number in PrintMessage
  #  ret   : Connect List(Array [PortName,FICE_DB::SignalInf,...])
  public
  def update_ConnectData(doc,target_module)
    INST_LIST[target_module] = get_InstanceList(doc,target_module)
    WIRE_LIST[target_module] = get_WireList(doc,target_module)
    PORT_LIST[target_module] = get_PortList(doc,target_module)
    ALL_CONNECT[target_module] = get_AllConnectList(doc,target_module)
  end


  public
  def search_Connection(clear_flag,doc,full_target_module,full_base_inst,base_port,search_all,connect_list=nil,hier=nil,num=0,stop_inst=nil,next_module_bus_portion=nil)

    # upper info
    upper_module = nil
    upper_inst = nil
    base_module = nil
    base_inst = nil
    # Resolve Multi-Hier for Module
    tmp = full_target_module.split(".")
    if tmp.size > 1
      target_module = tmp.pop
      upper_module = tmp.join(".")
    else
      target_module = full_target_module
    end
    # Resolve Multi-Hier for Instance
    if full_base_inst != nil
      tmp = full_base_inst.split(".")
      if tmp.size > 1
        base_inst = tmp.pop
        upper_inst = tmp.join(".")
      else
        base_inst = full_base_inst
      end
    end
    indent = ""
    num.times do
      indent = indent + "  "
    end
    if hier == nil && base_inst == nil
      hier = "Top"
    elsif hier == nil
      hier = "Middle"
    end

    # Get InstanceList on target_module
    inst_list = nil
    wire_list = nil
    port_list = nil
    if INST_LIST[target_module] == nil || clear_flag == true
      INST_LIST[target_module] = get_InstanceList(doc,target_module)
    end
    inst_list = INST_LIST[target_module]

    if WIRE_LIST[target_module] == nil || clear_flag == true
      WIRE_LIST[target_module] = get_WireList(doc,target_module)
    end
    wire_list = WIRE_LIST[target_module]

    if PORT_LIST[target_module] == nil || clear_flag == true
      PORT_LIST[target_module] = get_PortList(doc,target_module)
    end
    port_list = PORT_LIST[target_module]

#    inst_list = get_InstanceList(doc,target_module)
#    wire_list = get_WireList(doc,target_module)
#    port_list = get_PortList(doc,target_module)


    # Get Connect List for All-Instance
    if ALL_CONNECT[target_module] == nil || clear_flag == true
      ALL_CONNECT[target_module] = get_AllConnectList(doc,target_module)
    end
    all_connect = ALL_CONNECT[target_module]

    # Update "wire_list" for undefine wire
    all_connect.each do |name,data|
      data.each_value do |value|
        value.each do |each_data|
          wire_list[each_data.Name] = each_data
        end
      end
    end
    # Get Port Direction of base_port & Wire List
    base_port_direction = nil
    base_port_direction_org = nil
    module_name = nil
    case hier
    when "Top","NextModule","Connect"
      if port_list[base_port[0]] == nil
        base_port_direction_org = "Unknown"
      else
        base_port_direction_org = port_list[base_port[0]].Type
      end
      base_wire_list = [port_list[base_port[0]]]
    when "Middle"
      module_name = get_ModuleName(doc,target_module,base_inst)
      base_port_direction_org = get_PortDirection(doc,module_name,base_port[0],false)
      if all_connect[base_inst] == nil
        ALL_CONNECT[target_module] = get_AllConnectList(doc,target_module)
        all_connect = ALL_CONNECT[target_module]
        if all_connect[base_inst] != nil
          base_wire_list =  all_connect[base_inst][base_port[0]]
        end
      else
        base_wire_list = all_connect[base_inst][base_port[0]]
      end
#      FMakeMessage.PrintWarning( :category => "XMLParse", :no => 5, :inst => base_inst, :port => base_port[0], :module => target_module)  if base_wire_list == nil
    end
    if base_wire_list == nil
      printf("@I:Nothing Connect Wire about \"%s.%s\" in \"%s\" module.\n", base_inst,base_port[0],target_module) if $VERBOSE
=begin
      ALL_CONNECT[target_module] = get_AllConnectList(doc,target_module)
      all_connect = ALL_CONNECT[target_module]
      if all_connect[base_inst] != nil
        base_wire_list = all_connect[base_inst][base_port[0]]
        if base_wire_list != nil
          pp base_wire_list
          target_port_direction = "output"
        end
      else
        printf("@I:Nothing Connect Wire about \"%s.%s\" in \"%s\" module.\n", base_inst,base_port[0],target_module) if $VERBOSE
      end
=end
    end

    # Make Arrow for Print Message
    arrow, base_port_direction = get_ArrowDirection(base_port_direction_org,hier)
    # For Next Module
#    next_module_bus_portion = nil

    case hier
    when "Top"
      # Make New DB
      connect_list = FICE_DB::ConnectPath.new 
      base_port_inf = base_port[1]
      if base_port_inf != nil
        base_port_msb = base_port_inf.MSB
        base_port_lsb = base_port_inf.LSB
      else
        base_port_msb = nil
        base_port_lsb = nil
      end
      connect = FICE_DB::SignalInf.new( :module_name => target_module,
                                        :inst_name => nil,
                                        :name => base_port[0], 
                                        :msb => base_port_msb,
                                        :lsb => base_port_lsb,
                                        :type => base_port_direction_org)
      connect_list.addNode(connect,num)
      printf("[term]%s(%s:%s)\n",base_port[0],target_module,base_port_direction_org) if $VERBOSE
      num += 1
      num.times do
        indent = indent + "  "
      end
    when "NextModule"
      next_module_bus_portion = connect_list.SavedPath[num-1].last.BusPortion
      if next_module_bus_portion != nil
        printf("%s %s[Module term]%s[%d]:%s\n",indent,target_module,base_port[0],next_module_bus_portion,base_port_direction_org)  if $VERBOSE
      else
        printf("%s %s[Module term]%s:%s\n",indent,target_module,base_port[0],base_port_direction_org)  if $VERBOSE
      end  
    when "Connect"
      search_Connection(false,doc,target_module,full_base_inst,base_port,search_all,connect_list,"NextModule",num,stop_inst)
#      search_Connection(doc,target_module,nil,base_port,search_all,connect_list,"NextModule",num)
      return connect_list
    when "Middle"
      # Make New DB
      connect_list = FICE_DB::ConnectPath.new if num == 0
=begin
      connect = FICE_DB::SignalInf.new( :module_name => module_name,
                                        :inst_name => full_base_inst,
                                        :name => base_port, 
                                        :type => base_port_direction)      
      connect_list.addNode(connect,num)
      printf("[port]%s.%s(%s:%s)\n",full_base_inst,base_port,module_name,base_port_direction)
=end
      num += 1
      num.times do
        indent = indent + "  "
      end
    end
    # Execute for all wire connected port in target-instance. 
    connect_flag = false
    base_wire_list.each do |base_wire_tmp|
      if base_wire_tmp != nil
        base_wire =  FICE_DB::SignalInf.new( :module_name => base_wire_tmp.ModuleName,
                                             :inst_name => base_wire_tmp.InstName,
                                             :name => base_wire_tmp.Name,
                                             :connected_wire_name => base_wire_tmp.ConnectedWireName,
                                             :type => base_wire_tmp.Type,
                                             :msb => base_wire_tmp.MSB,
                                             :lsb => base_wire_tmp.LSB,
                                             :portion => base_wire_tmp.BusPortion,
                                             :word_top => base_wire_tmp.WordTop,
                                             :word_buttom => base_wire_tmp.WordButtom,
                                             :comment => base_wire_tmp.Comment
                                          )
      else
        base_wire = nil
      end
      if $VERBOSE
#        p base_wire
      end
#      printf("@I:searching about %s\n",base_wire.Name) if $VERBOSE
      case hier
      when "Middle"
        if next_module_bus_portion == nil
          printf("[port]%s.%s(%s[%s:%s])\n",full_base_inst,base_port[0],module_name,base_wire.Name,base_port_direction) if $VERBOSE
        else
          if $VERBOSE
            printf("@I: All Wire Connected Port\n")
            printf("  - next_module_bus_portion : %s\n",next_module_bus_portion)
            printf("  - base_wire.BusPortion : %s\n", base_wire.BusPortion)
          end
          if base_wire.MSB != nil
            if ( next_module_bus_portion.to_i > base_wire.MSB.to_i ) || ( next_module_bus_portion.to_i < base_wire.LSB.to_i )
              printf("@I: Skip for outSide BusPortion")
              next
            end
          elsif base_wire.BusPortion != nil
            if ( next_module_bus_portion.to_i > base_wire.BusPortion.to_i )
              printf("@I: Skip for mismatch BusPortion")
              next
            end
          end
          # next if ( next_module_bus_portion.to_i > base_wire.BusPortion.to_i ) && base_wire.BusPortion != nil
          #          printf("[port]%s.%s[%d](%s[%s:%s])\n",full_base_inst,base_port[0],base_wire.BusPortion,module_name,base_wire.Name,base_port_direction) if $VERBOSE
          printf("[port]%s.%s[%d](%s[%s:%s])\n",full_base_inst,base_port[0],next_module_bus_portion,module_name,base_wire.Name,base_port_direction) if $VERBOSE
        end
        # Make New DB
        base_port_inf = base_port[1]
        if base_port_inf != nil
          base_port_msb = base_port_inf.MSB
          base_port_lsb = base_port_inf.LSB
        else
          base_port_msb = nil
          base_port_lsb = nil
        end
        if next_module_bus_portion != nil
          portion = next_module_bus_portion
        else
          portion =  base_wire.BusPortion
        end
        connect = FICE_DB::SignalInf.new( :module_name => module_name,
                                          :inst_name => full_base_inst,
                                          :name => base_port[0], 
                                          :connected_wire_name => base_wire.Name,
                                          :portion => portion,
                                          :msb => base_port_msb,
                                          :lsb => base_port_lsb,
                                          :type => base_port_direction)      
        connect_list.addNode(connect,num-1)
        printf("@I:save %s in Connect-DB\n",base_port[0]) if $VERBOSE

        # Connect to Constant Value
        if base_wire.Type == "constant"
          connect = FICE_DB::SignalInf.new( :name => base_wire.Name, 
                                            :type => base_wire.Type,
                                            :msb => base_wire.MSB,
                                            :lsb => base_wire.LSB
                                            )      
          connect_list.addNode(connect,num)
          printf("  Connect to Constant Value(%s)\n",base_wire.Name) if $VERBOSE
          return connect_list
        end
      end

      # Non-Connect
      next if base_wire == nil
      # Connect Terminal ( There is teminal-connection )
      printf("Terminal Check\n") if $VERBOSE
      if base_wire != nil && port_list != nil && port_list[base_wire.Name] != nil
#        printf("@I:found port \"%s\"\n",port_list[base_wire.Name]) if $VERBOSE
        if hier != "NextModule" && hier != "Top" && upper_module != nil
          next_module_bus_portion = connect_list.SavedPath[num-1].last.BusPortion
          
          current_port_list = {}
          if PORT_LIST[target_module] == nil
            PORT_LIST[target_module] = get_PortList(doc,target_module)
          end
          current_port_list = PORT_LIST[target_module]


          if $VERBOSE
            printf("Upper Hierarchy(%s)\n",hier) 
            printf(" - target_module : %s\n",target_module)
            printf(" - upper_module : %s\n",upper_module)
            printf(" - upper_inst   : %s\n",upper_inst)
            printf(" - base_wire name : %s\n",base_wire.Name)
            printf(" - bus_portion  : %s\n",next_module_bus_portion)
            printf(" - port_direction : %s\n",current_port_list[base_wire.Name].Type) if current_port_list[base_wire.Name] != nil
            printf(" - base_port_direction : %s\n",base_port_direction)
          end
          port_direction = current_port_list[base_wire.Name].Type if current_port_list[base_wire.Name] != nil
          if base_port_direction == "input" && port_direction == "output"
            printf("@I: Stop search by Port-Direction. Base:%s, Port:%s", base_port_direction,port_direction) if $VERBOSE
#          elsif ( base_wire.MSB != nil && ( base_wire.MSB.to_i < next_module_bus_portion ) && ( )
          else
            sig_inf = FICE_DB::SignalInf.new( :module_name => module_name,
                                              :inst_name => full_base_inst,
                                              :name => base_wire.Name, 
                                              :connected_wire_name => base_wire.Name,
                                              #:portion => base_wire.BusPortion,
                                              :portion => next_module_bus_portion,
                                              :msb => base_port_msb,
                                              :lsb => base_port_lsb,
                                              :type => base_port_direction)
            if $VERBOSE
              printf("@I:Next search_Connection\n")
              printf("    - upper_module : %s\n",upper_module)
              printf("    - upper_inst   : %s\n",upper_inst)
              printf("    - base_wire.Name   : %s\n",base_wire.Name)
              printf("    - next_module_bus_portion : %s\n",next_module_bus_portion)
            end
            result = search_Connection(false,doc,upper_module,upper_inst,[base_wire.Name,sig_inf],search_all,connect_list,nil,num,stop_inst,next_module_bus_portion) 
            connect_flag = true 
          end
        else
#          terminal_list = get_TerminalList(doc,$TOP_MODULE)
          PORT_LIST[$TOP_MODULE] = get_PortList(doc,$TOP_MODULE) if PORT_LIST[$TOP_MODULE] == nil
          port_list = PORT_LIST[$TOP_MODULE]
#            port_list = get_PortList(doc,$TOP_MODULE)
#          if terminal_list.index(base_wire.Name) != nil && hier != "NextModule" && base_port_direction == port_list[base_wire.Name].Type
          if port_list[base_wire.Name] != nil && hier != "NextModule" && base_port_direction == port_list[base_wire.Name].Type
            # Connect Top Terminal
            printf("Connect Top Terminal(hire:%s)\n",hier) if $VERBOSE
            printf("%s%s [term] %s\n",indent,arrow,base_wire.Name) if $VERBOSE
            
            connect_flag = true
            connect = FICE_DB::SignalInf.new( :module_name => $TOP_MODULE,
                                              :inst_name => $TOP_MODULE,
                                              :name => base_wire.Name,
                                              :connected_wire_name => base_wire.Name,
                                              :portion => base_wire.BusPortion,
                                              :msb => base_wire.MSB,
                                              :lsb => base_wire.LSB,
                                              :type => base_port_direction)      
            connect_list.addNode(connect,num)
            printf("@I:save %s in Connect-DB\n",base_wire.Name) if $VERBOSE
            connect_flag = true
          end
        end  
      end
#      $VERBOSE = true
      # Connect Other instanc
      inst_list.each do |inst|
#        printf("@I:found connect to other instance \"%s\"(%s)\n",inst[1],inst[0])
        other_connect = all_connect[inst[1]]

        next_flag = false
        other_connect.each do |name,inf|
          target_port = get_PortInf(doc,inst[0],name,false)
          target_port_direction = target_port.Type if target_port != nil && target_port != "Unknown"
          if inst[1] == base_inst && hier != "NextModule" # Myself
            next_flag = true if  base_port_direction == "inout"
            next_flag = true if  target_port_direction == "inout"
            break
          end
        end
        next if next_flag

        other_connect.each do |name,inf|
         total_size = -1
          inf.each do |each_wire|
            total_size += each_wire.Size
          end
          inf.each do |each_wire|
#            p inst
#            p each_wire
            # Name Difference
            next if each_wire.Name != base_wire.Name
            if next_module_bus_portion != nil && each_wire.BusPortion != nil
              next if next_module_bus_portion != each_wire.BusPortion
            elsif next_module_bus_portion != nil && each_wire.BusPortion == nil
              # update BusPortion
#              printf("@I:update BusPortion to %d at %s\n",next_module_bus_portion,each_wire.Name) if $VERBOSE              
              base_wire.BusPortion = next_module_bus_portion
            end

=begin
            # Get Wire Information
            wire_inf = XMLParse::get_WireList(doc,target_module)[each_wire.Name]
            if wire_inf.nil?
              # No Wire Definition
            else
              # Wire Definition
            end
=end

            # Bus Portion or BusWidth Mistamatch
            if each_wire.BusPortion != base_wire.BusPortion
              # Bus Portio Mismatch
              if each_wire.BusPortion != nil && base_wire.BusPortion != nil
                next
              end
              # Extra Bus Portion
              if base_wire.BusPortion != nil && each_wire.MSB != nil && base_wire.LSB != nil
                if  base_wire.BusPortion > each_wire.MSB  || each_wire.LSB >  base_wire.BusPortion 
                  next
                end
              end
              # Extra Bus Portion
              if each_wire.BusPortion != nil && base_wire.MSB != nil && base_wire.LSB != nil
                if  each_wire.BusPortion > base_wire.MSB  || base_wire.LSB  > each_wire.BusPortion 
                  next
                end
              end
            end
            target_port = get_PortInf(doc,inst[0],name,false)
#            target_port_direction = get_PortDirection(doc,inst[0],name,false)
            target_port_direction = target_port.Type if target_port != nil && target_port != "Unknown"


            if base_port_direction == "inout" || ( base_port_direction != target_port_direction ) 
              inst_name = nil
              case hier
              when "NextModule"
                inst_name = full_base_inst + "." + inst[1]
              when "Middle"
                tmp = full_base_inst.split(".")
                if tmp.size == 1
                  inst_name = inst[1]
                else
                  tmp.pop
                  inst_name = tmp.join(".") + "." + inst[1]
                end
              else
                inst_name = inst[1]
              end
              if base_wire.BusPortion == nil
                printf("%s%s [wire]%s %s [port]%s.%s(%s:%s)\n",
                       indent,
                       arrow,
                       base_wire.Name,
                       arrow,
                       inst_name,
                       name,
                       inst[0],
                       target_port_direction
                       ) if $VERBOSE
              elsif each_wire.MSB == nil && each_wire.LSB == nil
                if ( target_port != nil && target_port != "Unknown" ) && target_port.BusPortion != nil
                  printf("%s%s [wire]%s[%d] %s [port]%s.%s[%d](%s:%s)\n",
                         indent,
                         arrow,
                         base_wire.Name,
                         base_wire.BusPortion,
                         arrow,
                         inst_name,
                         name,
                         total_size,
                         inst[0],
                         target_port_direction
                         ) if $VERBOSE
                  total_size -= each_wire.Size
                else
                  printf("%s%s [wire]%s[%d] %s [port]%s.%s(%s:%s)\n",
                         indent,
                         arrow,
                         base_wire.Name,
                         base_wire.BusPortion,
                         arrow,
                         inst_name,
                         name,
                         inst[0],
                         target_port_direction
                         ) if $VERBOSE
                  total_size -= each_wire.Size
                end
              else
                printf("%s%s [wire]%s[%d] %s [port]%s.%s[%d:%d](%s:%s)\n",
                       indent,
                       arrow,
                       base_wire.Name,
                       base_wire.BusPortion,
                       arrow,
                       inst_name,
                       name,
                       each_wire.MSB,
                       each_wire.LSB,
                       inst[0],
                       target_port_direction
                       ) if $VERBOSE
                total_size -= each_wire.Size
              end
              port_list = PORT_LIST[inst[0]]
              port = port_list[name] if port_list != nil
              if port != nil
                msb = port.MSB
                lsb = port.LSB
              else
                msb = each_wire.MSB
                lsb = each_wire.LSB
              end
              printf("@I:save %s in Connect-DB\n",name) if $VERBOSE
              if target_port != nil && target_port != "Unknown"
                target_port_portion = target_port.BusPortion
                target_port_size = target_port.Size
              else
                target_port_portion = nil
                target_port_size = 1
              end
              connect = FICE_DB::SignalInf.new( :module_name => inst[0],
                                                :inst_name => inst_name,
                                                :name => name, 
                                                :connected_wire_name => base_wire.Name,
                                                :portion => base_wire.BusPortion,
                                                :signal_portion => target_port_portion,
                                                :signal_size => target_port_size,
                                                :type => target_port_direction,
                                                :msb => msb,
                                                :lsb => lsb
                                                )
#                                                :type => base_port_direction)
              connect_list.addNode(connect,num)
              connect_flag = true
              if stop_inst != nil
                if search_all && ( stop_inst.index(inst_name) == nil )
#                  printf("@I:search next hier to \"%s(%s)\"\n",inst_name,inst[0]) if $VERBOSE
                  search_Connection(false,doc,inst[0],inst_name,[name,nil],search_all,connect_list,"Connect",num+1,stop_inst) 
                else
                  stop_inst_name =  stop_inst.index(inst_name)
                  printf("@I:stop connect search at %s\n",inst_name) if $VERBOSE
                end
              else
                if search_all 
                  search_Connection(false,doc,inst[0],inst_name,[name,nil],search_all,connect_list,"Connect",num+1) 
                end
              end
            end
          end
        end
      end if base_wire.Type != "open"
    end if base_wire_list != nil
    # Connect nothing
    print_final_connect(base_port_direction,hier,indent) if connect_flag == false && $VERBOSE == true
    return connect_list
  end

  #
  # Print Final Connect
  # - Only pirnt message of final connection 
  #
  def print_final_connect(base_port_direction,hier,indent)
    case base_port_direction
    when "input"
      case hier
      when "Top","NextModule","Connect"
        printf("%s --- Connect LOGIC\n",indent)
      when "Middle"
        printf("%sUndriven(It may be syntax error on Verilog-HDL)\n",indent)
      end
    when "output","inout"
      case hier
      when "Top","NextModule","Connect"
        printf("%s --- Connect LOGIC\n",indent)
      when "Middle"
        printf("%sOPEN/Non-Connect\n",indent)
      end
    end
  end      

  #
  # Get Arrow and Directional
  #  In Top Hier, The directional reverse
  #
  private
  def get_ArrowDirection(base_port_direction,hier)
    arrow = nil
    case base_port_direction
    when "input"
      case hier
      when "Top","NextModule","Connect"
        arrow = "->"
        base_port_direction = "output"
      when "Middle"
        arrow = "<-"
      end
    when "output"
      case hier
      when "Top","NextModule", "Connect"
        arrow = "<-"
        base_port_direction = "input"
      when "Middle"
        arrow = "->"
      end
    when "inout"
      arrow = "<->"
    when "Unknown"
      arrow = "?"
    end
    return arrow,base_port_direction
  end
  

  #--------------------------------------------------------------------------------------------
  # Following is Private Method for Support XML API
  #--------------------------------------------------------------------------------------------
  private
  def get_ModuleName(doc,target_module,target_inst)
    get_InstanceList(doc,target_module).each do |inst_list|
      return inst_list[0] if target_inst == inst_list[1]
    end
    return nil
  end
  

  private
  def xml_InstanceNode(port_name,port_inf,path="named_port_connection/IDENTIFIER")
    if port_inf == nil
      signal = FICE_DB::SignalInf.new(
                                      :name => nil,
                                      :type => "non-connect", 
                                      )
      
      port_inf = [signal]
    end
    n = port_inf.size
#    port_name =  port_inf[0]

    doc =  xml_NodeWithItem(port_name,path,nil,nil,false)
    
    # Open
    return doc if port_inf[0].Type == "open" || port_inf[0].Type == "non-connect"

    doc << elem0 = LibXML::XML::Node.new( 'expression' )
    elem0 << elem1 = LibXML::XML::Node.new( 'primary' )

    if port_inf.size > 1
      elem1 << elem2 = LibXML::XML::Node.new( 'concatenation' )
      elem_port = elem2
    end

    i = 0
    while i < port_inf.size
      port = port_inf[i]
      if port_inf.size > 2
        elem2 << elem3 = LibXML::XML::Node.new( 'expression' )
        elem3 << elem4 = LibXML::XML::Node.new( 'primary' )
        elem4 << item = xml_NodeWithItem(port.Name,"IDENTIFIER")        
        elem_port = elem4
      else
        if port.Type == "constant"
          /(\d+)('[a-zA-Z])(\d+)/ =~ port.Name
          unsigned_number = $1
          base =  $2
          number =  $3
          if unsigned_number == nil || base == nil || number == nil
            FMakeMessage.PrintInternalError( :category => "XMLParse", :no => 4, :file_name => File.basename(__FILE__), :lineno => __LINE__) 
          end
          elem1 << elem3 = LibXML::XML::Node.new( 'number' )
          elem3 << num0 = xml_NodeWithItem(unsigned_number,"UNSIGNED_NUMBER",nil,nil,false) # non-comment
          elem3 << num1 = xml_NodeWithItem(base,"BASE",nil,nil,false) # non-comment
          elem3 << num2 = xml_NodeWithItem(number,"NUMBER",nil,nil,false) # non-comment
          return doc # "constant" case, no need to care MSB/LSB, already changed constant value for bit-widht 
        else
          elem_port = elem1
          elem_port << item = xml_NodeWithItem(port.Name,"IDENTIFIER")        
        end
      end
      if port.BusPortion != nil
        # BusPortion
        elem_port << portion = xml_NodeWithItem(port.BusPortion,"expression/primary/number/DECIMAL_NUMBER")
      elsif port.MSB != nil && port.LSB != nil
        # Bus
        elem_port << msb = xml_NodeWithItem(port.MSB,"constant_expression/expression/primary/number/DECIMAL_NUMBER")
        elem_port << lsb = xml_NodeWithItem(port.LSB,"constant_expression/expression/primary/number/DECIMAL_NUMBER")
      end
      i += 1
    end
    return doc
  end

  private
  def xml_InstanceNodeFirst(port_name,port_inf,path="IDENTIFIER")
    if port_inf == nil
      signal = FICE_DB::SignalInf.new(
                                      :name => nil,
                                      :type => "non-connect", 
                                      )
      
      port_inf = [signal]
    end
    n = port_inf.size

    xml,doc =  xml_Node("list_of_module_connections/named_port_connection")
    doc << a =  xml_NodeWithItem(port_name,path,nil,nil,false)
    
    return xml if port_inf[0].Type == "non-connect"

    doc << elem0 = LibXML::XML::Node.new( 'expression' )
    elem0 << elem1 = LibXML::XML::Node.new( 'primary' )
    
    if port_inf.size > 1
      elem1 << elem2 = LibXML::XML::Node.new( 'concatenation' )
      elem_port = elem2
    end


    i = 0
    while i < n
      port = port_inf[i]
      if port_inf.size > 2
        elem2 << elem3 = LibXML::XML::Node.new( 'expression' )
        elem3 << elem4 = LibXML::XML::Node.new( 'primary' )
        elem4 << item = xml_NodeWithItem(port.Name,"IDENTIFIER")        
        elem_port = elem4
      else
        elem_port = elem1
        elem_port << item = xml_NodeWithItem(port.Name,"IDENTIFIER")        
      end
      if port.MSB != nil && port.LSB != nil
        # Bus
        elem_port << msb = xml_NodeWithItem(port.MSB,"constant_expression/expression/primary/number/DECIMAL_NUMBER")
        elem_port << lsb = xml_NodeWithItem(port.LSB,"constant_expression/expression/primary/number/DECIMAL_NUMBER")
      elsif port.BusPortion != nil
        # BusPortion
        elem_port << portion = xml_NodeWithItem(port.BusPortion,"expression/primary/number/DECIMAL_NUMBER")
      end
      i += 1
    end
    return xml
  end


  # Change connect related a module/instance include XML
  #  param : doc  (LibXML::XML::Document), 
  #          target_module - Module Name instantiated target_inst
  #          target_inst   - Instance Name include changing port
  #          target_port   - Port Name changing connection
  #          change_net    - Changing Net
  #  ret   : doc changed connection
  public
  def change_Connection(doc,target_module,target_inst,port,con_db)
    port.each do |port_name,signal|
      if XMLParse::delete_InstancePort(doc,target_module,target_inst,port_name) == false
        printf "Cannot execute Delete Instance Port about %s\n", port_name if $VERBOSE
#        exit
      end
      if XMLParse::add_InstancePort(doc,target_module,target_inst,{"#{port_name}" => signal},con_db) == false
#        p target_module
#        p target_inst
#        p port_name
#        p "@internal error"
#        exit
      end
    end

    # Add Port to target_instance
    return doc
  end

  # Change connect related a module/instance include XML
  #  param : doc  (LibXML::XML::Document), 
  #          target_module - Module Name instantiated target_inst
  #          target_inst   - Instance Name include changing port
  #          target_port   - Port Name changing connection
  #          change_net    - Changing Net
  #  ret   : doc changed connection
  public
  def change_ConnectionToPort(doc,target_module,target_inst,signal,con_db)
    XMLParse::add_Wire(doc,target_module,signal,con_db) if XMLParse::get_WireList(doc,target_module)[signal.Name] == nil
    XMLParse::add_Port(doc,target_module,signal)
    XMLParse::add_Terminal(doc,target_module,signal)

    # Add Port to target_instance
    return doc
  end


  #-------------------------------------------------------------------------------
  # Private Mechod
  #-------------------------------------------------------------------------------

  #
  # declaration
  #  param : declaration XML
  #  ret   : Name, MSB, LSB
  #
  private
  def declaration(declaration)
    name = Array.new
    msb = nil
    lsb = nil
    declaration.find( 'list_of_variables' ).each do |list_of_variable|
      #<list_of_variables>
      #	::= <name_of_variable> <,<name_of_variable>>*
      name += get_NAME_OF_VARIABLE(list_of_variable)
    end
    declaration.find( "range" ).each do |range|
      msb, lsb = get_msb_lsb(name.to_s,range)
    end
    declaration.find( "expandrange/range" ).each do |range|
      msb, lsb = get_msb_lsb(name.to_s,range)
    end
    return name, msb, lsb
  end

  #
  # reg_declaration
  #  param : declaration XML
  #  ret   : Name, MSB, LSB
  #
  private
  def reg_declaration(declaration)
    name = Array.new
    msb = nil
    lsb = nil
    word_top = nil
    word_buttom = nil
    declaration.find( "range" ).each do |range|
      msb, lsb = get_msb_lsb(name.to_s,range)
    end
    declaration.find( "expandrange/range" ).each do |range|
      msb, lsb = get_msb_lsb(name.to_s,range)
    end
    declaration.find( 'list_of_register_variables' ).each do |list_of_register_variables|
      #<list_of_register_variables>
      #	::= <register_variable> <,<register_variable>>*      
      list_of_register_variables.find( 'register_variable' ).each do |register_variable|
        #<register_variable>
        #	::= <name_of_register>
        #	||= <name_of_memory> [ <constant_expression> : <constant_expression> ]        
        
        # name_of_register
        name += get_NAME_OF_REGISTER(register_variable)
        
        # name_of_memory
        name += get_NAME_OF_MEMORY(register_variable)
        word_top, word_buttom = get_msb_lsb(name.to_s,register_variable)
      end
    end
    return name, msb, lsb, word_top, word_buttom
  end

  #
  # Save Port List
  #  param : direction, name, msb, lsb
  #  ret   : FICE_DB::SignalInf
  #
  private
  def save_SignalList(port,type,name,msb,lsb,word_top=nil,word_buttom=nil)
    name.each do |each_name|
      port[each_name] = FICE_DB::SignalInf.new( :name => each_name, :type => type, :msb => msb, :lsb => lsb, :word_top => word_top, :word_buttom => word_buttom)
    end
    return port
  end

  #
  # get Signal Name
  #  param : doc
  #  ret   : list
  private
  def get_NAME_OF_VARIABLE(doc)
    list = Array.new
    doc.find( "#{NAME_OF_VARIABLE}" ).each do |port_name|
      list << port_name.content.strip.split[0]
    end
    return list
  end

  #
  # get Register Name
  #  param : doc
  #  ret   : list
  private
  def get_NAME_OF_REGISTER(doc)
    list = Array.new
    doc.find( "#{NAME_OF_REGISTER}" ).each do |reg_name|
      list << reg_name.content.strip.split[0]
    end
    return list
  end

  #
  # get Memory Name
  #  param : doc
  #  ret   : list
  private
  def get_NAME_OF_MEMORY(doc)
    list = Array.new
    doc.find( "#{NAME_OF_MEMORY}" ).each do |mem_name|
      list << mem_name.content.strip.split[0]
    end
    return list
  end

  #
  # get Module Name
  #  param : doc
  #  ret   : module name
  def get_NAME_OF_MODULE(doc)
    module_name = Array.new
    doc.find( "#{NAME_OF_MODULE}" ).each do |mod_name|
      module_name <<  mod_name.content.strip.split[0]
    end
    if module_name.size == 1
      return module_name[0]
=begin
      module_name.each do |each|
        return each
      end
=end
    else
      return module_name
    end
  end

  # get Instance Name
  #  param : doc
  #  ret   : instance name
  private
  def get_NAME_OF_INSTANCE(doc)
    list = nil
    doc.find( 'name_of_instance/IDENTIFIER' ).each do |inst_name|
      list = inst_name.content.strip.split[0]
      return list
    end   
    return list
  end

  # ger named_port_connection
  private
  def get_named_port_connection(root,connect_list,doc,target_module)
    connect_list_each = Array.new
    # get Port name
    port_name = nil
    doc.find( 'IDENTIFIER' ).each do |named_port|
      port_name = named_port.content.strip.split[0]
      break
    end
    flag = false
    doc.find( 'expression' ).each do |expression|
      #<expression>
      #	::= <primary>
      #	||= <UNARY_OPERATOR> <primary>
      #	||= <expression> <BINARY_OPERATOR> <expression>
      #	||= <expression> <QUESTION_MARK> <expression> : <expression>
      #	||= <STRING>

      # 1-Signal
      net_name = get_expression(expression)
      if net_name != nil
        msb = nil
        lsb = nil
        portion = nil
        expression.find( 'primary').each do |primary|
          msb,lsb = get_msb_lsb(net_name,primary,"constant_expression/expression/primary/number/*")
          portion = get_portion(primary,"expression/primary/number/*")
          break
        end
        # save net information to ConnectList
=begin
        wire_list = nil
        # Caching Wire_list
        if WIRE_LIST[target_module] == nil
          WIRE_LIST[target_module] = XMLParse::get_WireList(root,target_module)
        end
        wire_list = WIRE_LIST[target_module]          
        net =  wire_list[net_name]
        if net != nil
          net_inf = FICE_DB::SignalInf.new( :name => net_name, :type => "wire", :msb => net.MSB, :lsb => net.LSB, 
                                           :portion => net.BusPortion, :word_top => net.WordTop, :word_buttom => net.WordButtom)
        else
          net_inf = FICE_DB::SignalInf.new( :name => net_name, :type => "wire", :msb => msb, :lsb => lsb, :portion => portion)
        end
=end
        net_inf = FICE_DB::SignalInf.new( :name => net_name, :type => "wire", :msb => msb, :lsb => lsb, :portion => portion)
        connect_list_each << net_inf
        connect_list[port_name] = connect_list_each        
      end

      # Multi-Signal
      expression.find( 'primary/concatenation/expression/primary').each do |primary|
        connect_list_each << get_primary(primary)
        connect_list[port_name] = connect_list_each        
      end

      # Constant Value
      constant = ""
      expression.find( 'primary/number/*').each do |number|
        constant = constant + number.content.strip
      end
      if constant != ""
        net_inf = FICE_DB::SignalInf.new( :name => constant, :type => "constant")
        connect_list_each << net_inf
      end

      connect_list[port_name] = connect_list_each
      flag = true        
    end
    # Open
    if !flag
      net_inf = FICE_DB::SignalInf.new( :name => nil, :type => "open")
      connect_list_each << net_inf
      connect_list[port_name] = connect_list_each
    end
    return connect_list
  end

  #
  # get primary
  #  param : primary XMLS
  #  ret   : FICE_DB:SignalInf
  def get_primary(primary)
    name = nil
    type = "wire"
    portion = nil
    msb = nil
    lsb = nil
    
    primary.find( 'IDENTIFIER').each do |net_name|
      name = net_name.content.strip.split[0]
    end
    primary.find( "expression/*").each do |num|
      portion =  num.content.strip.to_i
    end
    msb,lsb = get_msb_lsb(name,primary)
    
    return  FICE_DB::SignalInf.new( :name => name, :type => type, :portion => portion, :msb => msb, :lsb => lsb)
  end

  #
  # get MSB/LSB
  #  param : doc
  #  ret   : msb, lsb
  #
  private
  def get_msb_lsb(name,doc,path="constant_expression/expression/*")
    cnt = 0
    msb = nil
    lsb = nil
    doc.find( "#{path}" ).each do |num|
      case cnt
      when 0
        msb =  num.content.strip.to_i
      when 1
        lsb =  num.content.strip.to_i
      else
        FMakeMessage.PrintNote( :category => "XMLParse", :no => 6, :port => name) 
        msb = nil
        lsb = nil
        return msb,lsb
#        FMakeMessage.PrintInternalError( :category => "XMLParse", :no => 1, :file_name => File.basename(__FILE__), :lineno => __LINE__) 
      end
      cnt += 1
    end
    return msb,lsb
  end

  #
  # get Portion
  #  param : doc
  #  ret   : portion
  #
  private
  def get_portion(doc,path=nil)
    cnt = 0
    portion = nil
    doc.find( "#{path}" ).each do |num|
      portion =  num.content.strip.to_i
      return portion
    end
    return portion
  end


  #
  # get Expression
  #   param : doc
  #   ret   : name
  #
  private
  def get_expression(doc)
    doc.find( "#{PRIMARY}" ).each do |primary|
      #<primary>
      #	::= <number>
      #	||= <identifier>
      #	||= <identifier> [ <expression> ]
      #	||= <identifier> [ <constant_expression> : <constant_expression> ]
      #	||= <concatenation>
      #	||= <multiple_concatenation>
      #	||= <function_call>
      #	||= ( <mintypmax_expression> )                        
      return primary.content.strip.split[0]
    end
  end

  # 
  # get NETTYPE
  #  param : doc
  #  ret   : nettye
  #
  private
  def get_NETTYPE(doc)
    doc.find( "#{NETTYPE}" ).each do |nettype|
      #<NETTYPE> is one of the following keywords:
      #	wire  tri  tri1  supply0  wand  triand  tri0  supply1  wor  trior  trireg      
      return nettype.content.strip.split[0]
    end
  end
  

  #
  # make_TerminalXML
  #  param : portDB
  #  ret   : Terminal XML 
  #
  private
  def make_TerminalXML(port)
    doc =  xml_NodeWithItem(port.Name,"port/port_expression/port_reference/name_of_variable/IDENTIFIER")
=begin
    xml = LibXML::XML::Node.new( 'AAA' )
    xml << elem1 = LibXML::XML::Node.new( 'BBB' )
    elem1 << elem2 = LibXML::XML::Node.new( 'CCC' )
    elem2 << elem3 = LibXML::XML::Node.new( 'DDD' )
    elem3 << port.Name
=end
    return doc
  end


  #
  # Make PortXML
  # 
  private
  def make_PortXML(port)
    case port.Type
    when "input"
      doc =  xml_MultiNode(port,"module_item/input_declaration",port.Type)
    when "output"
      doc =  xml_MultiNode(port,"module_item/output_declaration",port.Type)
    when "inout"
      doc =  xml_MultiNode(port,"module_item/inout_declaration",port.Type)
    end
    return doc
  end

  private
  def xml_NodeWithItem(name,str=nil,xml=nil,doc=nil,comment_flag=true)
    tags = str.split("/")
    if tags.size == 0
=begin Implemet Other Comment method
      if name.class == String && comment_flag == true
        name = name + " /* FMake */"
      end
=end
      doc << name
      return xml
    end

    if xml == nil
      value = tags.shift
      xml = LibXML::XML::Node.new( "#{value}" )
      xml_NodeWithItem(name,tags.join("/"),xml,xml,comment_flag)
    else
      value = tags.shift
      doc << elem1 = LibXML::XML::Node.new( "#{value}" )
      xml_NodeWithItem(name,tags.join("/"),xml,elem1,comment_flag)
    end
  end

  private
  def xml_Node(str=nil,xml=nil,doc=nil)
    tags = str.split("/")
    if tags.size == 0
      return xml,doc
    end

    if xml == nil
      value = tags.shift
      xml = LibXML::XML::Node.new( "#{value}" )
      xml_Node(tags.join("/"),xml,xml)
    else
      value = tags.shift
      doc << elem1 = LibXML::XML::Node.new( "#{value}" )
      xml_Node(tags.join("/"),xml,elem1)
    end
  end


  private
#  def xml_MultiNode(port,base,port_path="list_of_variables/name_of_variable/IDENTIFIER",value_path="constant_expression/expression/primary/number/DECIMAL_NUMBER",reserved_word=nil)
  def xml_MultiNode(port,base,reserved_word=nil)
    port_path = "list_of_variables/name_of_variable/IDENTIFIER"
    value_path = "constant_expression/expression/primary/number/DECIMAL_NUMBER"
    
#    doc = LibXML::XML::Node.new( "#{base}" )
    xml,doc = xml_Node("#{base}") unless base.nil?

    if base == "module_item/net_declaration"
      doc << net = LibXML::XML::Node.new( 'NETTYPE' )
      net << "wire"
    else
      doc << net = LibXML::XML::Node.new( 'reserved' )
      net << reserved_word
    end

    if port.MSB != nil && port.LSB != nil
      if base == "module_item/net_declaration"
        doc << doc1 = LibXML::XML::Node.new( "expandrange" )
        doc1 << range = LibXML::XML::Node.new( "range" )
      else
        doc << range = LibXML::XML::Node.new( "range" )
      end
      range << msb = xml_NodeWithItem(port.MSB,"#{value_path}")
      range << lsb = xml_NodeWithItem(port.LSB,"#{value_path}")
    end
#    if port.BusPortion != nil      
#      FMakeMessage.PrintInternalError( :category => "XMLParse", :no => 100, :file_name => File.basename(__FILE__), :lineno => __LINE__, 
#                                       :comment => "Now, not support BusPortion Format at add_Port API")
#    end

    doc << port_path = xml_NodeWithItem(port.Name,"#{port_path}")

    return xml
  end

  private
  def xml_addInstanceNode(inst_inf,base,module_path,inst_path)
    xml,doc = xml_Node("#{base}") unless base.nil?
    
    doc << mod = xml_NodeWithItem(inst_inf[0],"#{module_path}")
    doc << inst = xml_NodeWithItem(inst_inf[1],"#{inst_path}")

    return xml
  end



  public

  # File Interface
  module_function :read
  module_function :save
  module_function :add_doc

  # For Module
  module_function :get_ModuleList
#  module_function :add_Module
  module_function :delete_Module
  module_function :delete_HardMacro
  module_function :change_ModuleName

  # For Terminal
  module_function :get_TerminalList
  module_function :add_Terminal
  module_function :delete_Terminal
  
  # For Parameter
  module_function :get_Parameter

  # For Port
  module_function :get_PortList
  module_function :get_PortListBase
  module_function :get_PortDirection
  module_function :get_PortInf
  module_function :add_Port
  module_function :delete_Port

  # For Wire
  module_function :get_WireList
  module_function :add_Wire
  module_function :delete_Wire

  # For Reg
  module_function :get_RegList
#  module_function :add_Reg        # Ver2.0 Not Support, Next Version
#  module_function : delete_Reg    # Ver2.0 Not Support, Next Version

  # For Instance
  module_function :get_InstanceList
  module_function :change_InstanceModule
  module_function :add_Instance
  module_function :add_InstancePort
  module_function :delete_InstancePort
  

  # For Connection
  module_function :get_ConnectList
  module_function :get_ConnectListwithPort
  module_function :get_AllConnectList
#  module_function :add_Connnect
#  module_function :delete_Connect


  # Change Circuit Information
  module_function :change_Connection
  module_function :change_ConnectionToPort

  module_function :update_ConnectData
  module_function :search_Connection

  private


  # Private Method
  module_function :declaration
  module_function :reg_declaration
  module_function :save_SignalList
  module_function :get_ModuleName
  module_function :get_NAME_OF_MODULE
  module_function :get_NAME_OF_VARIABLE
  module_function :get_NAME_OF_REGISTER
  module_function :get_NAME_OF_MEMORY
  module_function :get_NAME_OF_INSTANCE
  module_function :get_named_port_connection
  module_function :get_expression
  module_function :get_msb_lsb
  module_function :get_portion
  module_function :get_NETTYPE
  module_function :get_primary

  module_function :make_TerminalXML
  module_function :make_PortXML

  module_function :xml_Node
  module_function :xml_NodeWithItem
  module_function :xml_MultiNode
  module_function :xml_InstanceNode
  module_function :xml_InstanceNodeFirst
  module_function :xml_addInstanceNode

  module_function :get_ArrowDirection
  module_function :print_final_connect
  
end

